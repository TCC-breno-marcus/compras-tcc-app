name: Deploy TCC - Produção

on:
  push:
    branches: [ "main" ]

jobs:
  tests:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout do código
        uses: actions/checkout@v4

      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: '8.0.x'

      - name: Testes do backend (.NET)
        run: |
          dotnet restore backend/backend.sln
          dotnet test backend/backend.sln --configuration Release --no-restore

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: npm
          cache-dependency-path: frontend/package-lock.json

      - name: Instalar dependências do frontend
        working-directory: frontend
        run: npm ci

      - name: Testes unitários do frontend (Vitest)
        working-directory: frontend
        run: npm run test:unit -- --run

      - name: Criar .env para stack de E2E no CI
        run: |
          cat > .env << 'EOF'
          DB_USER=postgres
          DB_PASSWORD=postgres
          DB_NAME=compras_db
          ASPNETCORE_ENVIRONMENT=Development
          JWT_KEY=chave-super-secreta-para-ci-com-32-bytes
          JWT_ISSUER=compras-tcc-ci
          JWT_AUDIENCE=compras-tcc-ci
          EOF

      - name: Subir stack para E2E
        run: docker compose up -d --build postgres-db backend-service frontend-service cypress

      - name: Aguardar frontend no ar
        run: |
          for i in {1..60}; do
            if curl -sSf http://localhost:5173 > /dev/null; then
              exit 0
            fi
            sleep 5
          done
          echo "Frontend não ficou disponível a tempo"
          exit 1

      - name: Aguardar backend no ar
        run: |
          for i in {1..60}; do
            if (echo > /dev/tcp/127.0.0.1/5000) >/dev/null 2>&1; then
              exit 0
            fi
            sleep 5
          done
          echo "Backend não ficou disponível a tempo"
          exit 1

      - name: Instalar dependências no container Cypress
        run: docker compose exec -T cypress npm ci

      - name: Rodar testes E2E (Cypress)
        run: docker compose exec -T cypress npx cypress run --e2e

      - name: Encerrar stack de E2E
        if: always()
        run: docker compose down -v

  build-and-push:
    needs: tests
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write

    steps:
      - name: Checkout do código
        uses: actions/checkout@v4

      - name: Login no GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      # Build do Backend
      - name: Build e Push Backend
        uses: docker/build-push-action@v5
        with:
          context: ./backend
          file: ./backend/Dockerfile.prod
          push: true
          tags: ghcr.io/tcc-breno-marcus/compras-tcc-app/backend:latest

      # Build do Frontend
      - name: Build e Push Frontend
        uses: docker/build-push-action@v5
        with:
          context: ./frontend
          file: ./frontend/Dockerfile.prod
          build-args: |
            SERVER_HOST=${{ secrets.VM_HOST }}
          push: true
          tags: ghcr.io/tcc-breno-marcus/compras-tcc-app/frontend:latest

  deploy:
    needs: build-and-push
    runs-on: ubuntu-latest

    steps:
      - name: Deploy via SSH na VM Oracle
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.VM_HOST }}
          username: ubuntu
          key: ${{ secrets.VM_SSH_PRIVATE_KEY }}
          script_stop: true
          script: |
            # Navega até a pasta
            cd ~/compras-tcc-app
            
            # Atualiza o código
            git checkout main
            git pull origin main
            
            # Faz login no registro de imagens (usando token pessoal na VM)
            echo "${{ secrets.VM_PAT }}" | docker login ghcr.io -u ${{ github.actor }} --password-stdin
            
            # Baixa as novas imagens
            docker compose -f docker-compose.prod.yml pull
            
            # Reinicia os serviços (recriando apenas os que mudaram)
            docker compose -f docker-compose.prod.yml up -d --remove-orphans
            
            # Limpeza de imagens antigas para economizar espaço
            docker image prune -f
